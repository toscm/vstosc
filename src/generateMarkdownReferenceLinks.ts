import * as vscode from 'vscode';

/**
 * Generate a GitHub/VS Code compatible slug from heading text
 * Rules:
 * - Lowercase
 * - Trim whitespace
 * - Replace spaces with hyphens
 * - Remove non-alphanumeric characters except hyphens
 * - Collapse multiple consecutive hyphens
 */
export function generateSlug(headingText: string): string {
    return headingText
        .toLowerCase()
        .trim()
        .replace(/\s+/g, '-')                    // Replace spaces with hyphens
        .replace(/[^a-z0-9-]/g, '')              // Remove non-alphanumeric except hyphens
        .replace(/-+/g, '-')                     // Collapse multiple hyphens
        .replace(/^-+|-+$/g, '');                // Remove leading/trailing hyphens
}

/**
 * Track slug usage and disambiguate duplicates by adding numeric suffixes
 */
export function disambiguateSlugs(slugs: string[]): string[] {
    const slugCounts = new Map<string, number>();
    const result: string[] = [];

    for (const slug of slugs) {
        const count = slugCounts.get(slug) || 0;
        slugCounts.set(slug, count + 1);

        if (count === 0) {
            result.push(slug);
        } else {
            result.push(`${slug}-${count}`);
        }
    }

    return result;
}

/**
 * Extract all headings from the document using VS Code's DocumentSymbolProvider
 */
async function getHeadings(document: vscode.TextDocument): Promise<string[]> {
    const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
        'vscode.executeDocumentSymbolProvider',
        document.uri
    );

    if (!symbols) {
        return [];
    }

    const headings: string[] = [];

    function collectHeadings(symbolList: vscode.DocumentSymbol[]) {
        for (const symbol of symbolList) {
            // In Markdown, headings are typically represented with SymbolKind.String
            // in VS Code's built-in Markdown language support
            if (symbol.kind === vscode.SymbolKind.String) {
                headings.push(symbol.name);
            }

            // Recursively collect headings from children
            if (symbol.children && symbol.children.length > 0) {
                collectHeadings(symbol.children);
            }
        }
    }

    collectHeadings(symbols);
    return headings;
}

/**
 * Find the range of the existing autogenerated block, if any
 */
function findExistingBlock(document: vscode.TextDocument): vscode.Range | null {
    const startMarker = '<!-- Start Reference Links (Autogenerated) -->';
    const endMarker = '<!-- End Reference Links (Autogenerated) -->';
    
    let startLine = -1;
    let endLine = -1;

    for (let i = 0; i < document.lineCount; i++) {
        const lineText = document.lineAt(i).text.trim();
        if (startLine === -1 && lineText === startMarker) {
            startLine = i;
        }
        if (startLine !== -1 && lineText === endMarker) {
            endLine = i;
            break;
        }
    }

    if (startLine !== -1 && endLine !== -1 && endLine >= startLine) {
        return new vscode.Range(
            new vscode.Position(startLine, 0),
            new vscode.Position(endLine, document.lineAt(endLine).text.length)
        );
    }

    return null;
}

/**
 * Generate the reference links block content
 */
function generateReferenceLinksBlock(headings: string[]): string {
    const lines = [
        '<!-- Start Reference Links (Autogenerated) -->'
    ];

    if (headings.length > 0) {
        const slugs = headings.map(h => generateSlug(h));
        const uniqueSlugs = disambiguateSlugs(slugs);

        for (let i = 0; i < headings.length; i++) {
            lines.push(`[${headings[i]}]: #${uniqueSlugs[i]}`);
        }
    }

    lines.push('<!-- End Reference Links (Autogenerated) -->');

    return lines.join('\n');
}

/**
 * Main command to generate markdown reference links
 */
export async function generateMarkdownReferenceLinks() {
    const editor = vscode.window.activeTextEditor;
    
    if (!editor) {
        vscode.window.showInformationMessage('No active text editor found.');
        return;
    }

    const document = editor.document;

    // Check if it's a markdown document
    if (document.languageId !== 'markdown') {
        vscode.window.showInformationMessage('This command only works with Markdown files.');
        return;
    }

    // Get headings from the document
    const headings = await getHeadings(document);

    // Check if there's an existing block
    const existingBlock = findExistingBlock(document);

    // If no headings and no existing block, nothing to do
    if (headings.length === 0 && !existingBlock) {
        vscode.window.showInformationMessage('No headings found in the document.');
        return;
    }

    // Generate the reference links block (even if empty, to clean up existing block)
    const referenceBlock = generateReferenceLinksBlock(headings);

    await editor.edit(editBuilder => {
        if (existingBlock) {
            // Replace or remove existing block
            if (headings.length === 0) {
                // Remove existing block if there are no headings
                const extendedRange = new vscode.Range(
                    existingBlock.start.line > 0 ? 
                        new vscode.Position(existingBlock.start.line - 1, document.lineAt(existingBlock.start.line - 1).text.length) :
                        existingBlock.start,
                    existingBlock.end
                );
                editBuilder.delete(extendedRange);
            } else {
                // Replace existing block
                editBuilder.replace(existingBlock, referenceBlock);
            }
        } else {
            // Append to end of document (only if there are headings)
            if (headings.length > 0) {
                const lastLine = document.lineAt(document.lineCount - 1);
                const endPosition = lastLine.range.end;
                
                // Add newlines before the block if the document doesn't end with a newline
                const prefix = lastLine.text.length > 0 ? '\n\n' : '';
                editBuilder.insert(endPosition, prefix + referenceBlock + '\n');
            }
        }
    });

    if (headings.length > 0) {
        vscode.window.showInformationMessage(`Generated reference links for ${headings.length} heading${headings.length === 1 ? '' : 's'}.`);
    } else if (existingBlock) {
        vscode.window.showInformationMessage('Removed reference links block (no headings found).');
    }
}
