import * as vscode from 'vscode';

/**
 * Generate a GitHub/VS Code compatible slug from heading text
 * Rules:
 * - Lowercase
 * - Trim whitespace
 * - Replace spaces with hyphens
 * - Remove non-alphanumeric characters except hyphens
 * - Collapse multiple consecutive hyphens
 */
export function generateSlug(headingText: string): string {
    return headingText
        .toLowerCase()
        .trim()
        .replace(/\s+/g, '-')                    // Replace spaces with hyphens
        .replace(/[^a-z0-9\-]/g, '')             // Remove non-alphanumeric except hyphens
        .replace(/-+/g, '-')                     // Collapse multiple hyphens
        .replace(/^-+|-+$/g, '');                // Remove leading/trailing hyphens
}

/**
 * Track slug usage and disambiguate duplicates by adding numeric suffixes
 */
export function disambiguateSlugs(slugs: string[]): string[] {
    const slugCounts = new Map<string, number>();
    const result: string[] = [];

    for (const slug of slugs) {
        const count = slugCounts.get(slug) || 0;
        slugCounts.set(slug, count + 1);

        if (count === 0) {
            result.push(slug);
        } else {
            result.push(`${slug}-${count}`);
        }
    }

    return result;
}

/**
 * Extract all headings from the document using VS Code's DocumentSymbolProvider
 */
async function getHeadings(document: vscode.TextDocument): Promise<Array<{ text: string; level: number }>> {
    const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
        'vscode.executeDocumentSymbolProvider',
        document.uri
    );

    if (!symbols) {
        return [];
    }

    const headings: Array<{ text: string; level: number }> = [];

    function collectHeadings(symbolList: vscode.DocumentSymbol[]) {
        for (const symbol of symbolList) {
            // In Markdown, headings are represented with SymbolKind.String
            // The level is not directly available, but we can infer it from the symbol
            if (symbol.kind === vscode.SymbolKind.String) {
                headings.push({
                    text: symbol.name,
                    level: 0 // We don't use level for now, just collect all headings
                });
            }

            // Recursively collect headings from children
            if (symbol.children && symbol.children.length > 0) {
                collectHeadings(symbol.children);
            }
        }
    }

    collectHeadings(symbols);
    return headings;
}

/**
 * Find the range of the existing autogenerated block, if any
 */
function findExistingBlock(document: vscode.TextDocument): vscode.Range | null {
    const startMarker = '<!-- Start Reference Links (Autogenerated) -->';
    const endMarker = '<!-- End Reference Links (Autogenerated) -->';
    
    let startLine = -1;
    let endLine = -1;

    for (let i = 0; i < document.lineCount; i++) {
        const lineText = document.lineAt(i).text;
        if (lineText.includes(startMarker)) {
            startLine = i;
        }
        if (lineText.includes(endMarker)) {
            endLine = i;
            break;
        }
    }

    if (startLine !== -1 && endLine !== -1 && endLine >= startLine) {
        return new vscode.Range(
            new vscode.Position(startLine, 0),
            new vscode.Position(endLine, document.lineAt(endLine).text.length)
        );
    }

    return null;
}

/**
 * Generate the reference links block content
 */
function generateReferenceLinksBlock(headings: Array<{ text: string; level: number }>): string {
    if (headings.length === 0) {
        return '';
    }

    const slugs = headings.map(h => generateSlug(h.text));
    const uniqueSlugs = disambiguateSlugs(slugs);

    const lines = [
        '<!-- Start Reference Links (Autogenerated) -->'
    ];

    for (let i = 0; i < headings.length; i++) {
        lines.push(`[${headings[i].text}]: #${uniqueSlugs[i]}`);
    }

    lines.push('<!-- End Reference Links (Autogenerated) -->');

    return lines.join('\n');
}

/**
 * Main command to generate markdown reference links
 */
export async function generateMarkdownReferenceLinks() {
    const editor = vscode.window.activeTextEditor;
    
    if (!editor) {
        vscode.window.showInformationMessage('No active text editor found.');
        return;
    }

    const document = editor.document;

    // Check if it's a markdown document
    if (document.languageId !== 'markdown') {
        vscode.window.showInformationMessage('This command only works with Markdown files.');
        return;
    }

    // Get headings from the document
    const headings = await getHeadings(document);

    if (headings.length === 0) {
        vscode.window.showInformationMessage('No headings found in the document.');
        return;
    }

    // Generate the reference links block
    const referenceBlock = generateReferenceLinksBlock(headings);

    // Check if there's an existing block
    const existingBlock = findExistingBlock(document);

    await editor.edit(editBuilder => {
        if (existingBlock) {
            // Replace existing block
            editBuilder.replace(existingBlock, referenceBlock);
        } else {
            // Append to end of document
            const lastLine = document.lineAt(document.lineCount - 1);
            const endPosition = lastLine.range.end;
            
            // Add newlines before the block if the document doesn't end with a newline
            const prefix = lastLine.text.length > 0 ? '\n\n' : '';
            editBuilder.insert(endPosition, prefix + referenceBlock + '\n');
        }
    });

    vscode.window.showInformationMessage(`Generated reference links for ${headings.length} heading${headings.length === 1 ? '' : 's'}.`);
}
